<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBX079301A838A74CE894528F03803F6F8E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">Music</string>
			<string name="ScriptGuid">{C3964A12-AC9F-4411-87D7-F7B291A534D7}</string>
			<ProtectedString name="Source"><![CDATA[client = nil
service = nil

return function(data, env)
	if env then
		setfenv(1, env)
	end


	-- Saving those microseconds from using the dot operator

	local Variables = client.Variables
	local Functions = client.Functions

	-- Some pre-defined "global" variables

	local gTable
	local song = data.Song
	local sImg
	local gImg
	local visualiserModule = nil
	local visualiser = nil
	local isMuted = false
	local isGlobal = false
	local activeSongList = nil
	local availableSongLists = {}
	local selected = nil
	local shuffle = false
	local loop = false
	local soundInstanceEndedEvent = nil
	local persistVolume = 0.25
	local audioLib = nil
	local controlPositionSlider = nil
	local progressupdatewait = 0.05
	local canUseGlobal = data.GlobalPerms

	-- The audio visulaiser at the top of the menu.

	local visualiserModule = require(script:FindFirstChild("Visualizer"))
	local sliderModule = require(script:FindFirstChild("Slider"))
	local localAudioLib = client.Shared:FindFirstChild("AudioLib")
	localAudioLib = require(localAudioLib).new(service.LocalContainer())

	local localAudioLibFunction = function(func, args)
		return localAudioLib[func](localAudioLib, args)
	end
	audioLib = localAudioLibFunction


	-- Function to run when we close the window

	local function doOnClose()
		if visualiser then
			visualiser:UnlinkFromSound()
			visualiser:Destroy()
			visualiser = nil
		end
		if visualiserModule then
			visualiserModule = nil
		end
		audioLib("UpdateSound", {
			Playing = false;
		})
	end

	-- The when the who the when the window

	local window = client.UI.Make("Window", {
		Name = "Audio Player";
		Title = "Audio Player";
		Size = {420, 400};
		MinSize = {420, 245};
		icon = "http://www.roblox.com/asset/?id=7032721624";
		Position = UDim2.new(0, 10, 1, -410);
		OnClose = function()
			doOnClose()
		end
	})

	-- The controls frame at the bottom of the window

	local controls = window:Add("Frame", {
		Size = UDim2.new(1, 0, 0, 75);
		Position = UDim2.new(0, 0, 1, -75);
		BackgroundColor3 = Color3.new(0.235294, 0.235294, 0.235294);
		BackgroundTransparency = 0;
	})

	-- Volume
	local controlVolume = controls:Add("TextLabel", {
		Text = "   ";
		ToolTip = "Volume: How loud the audio will play (0 to 10).";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 120, 0, 30);
		Position = UDim2.new(1, -125, 1, -35);
		TextXAlignment = "Left";
	})

	controlVolume:Add("ImageLabel", {
		Image = "rbxassetid://7541896266";
		Size = UDim2.new(0, 20, 0, 20);
		Position = UDim2.new(0, 5, 0, 5);
		BackgroundTransparency = 1;
	})

	local controlVolumeSliderContainer = controlVolume:Add("Frame", {
		Image = "rbxassetid://7541896266";
		Size = UDim2.new(1, -45, 0, 2);
		Position = UDim2.new(0, 30, 0, 14);
		BackgroundColor3 = Color3.new(0.454902, 0.454902, 0.454902);
		BackgroundTransparency = 0;
	})

	local controlVolumeSliderInstance = controlVolumeSliderContainer:Add("ImageButton", {
		Name = "Slider";
		--Text = "";
		Size = UDim2.new(0, 10, 0, 10);
		Position = UDim2.new(0, 0, 0, -4);
		BackgroundColor3 = Color3.new(1,1,1);
		BackgroundTransparency = 0;
		TextXAlignment = "Right";
		Children = {
			UICorner = {
				CornerRadius = UDim.new(1, 0);
			}
		}
	})

	local controlVolumeSlider = sliderModule.new(service.UnWrap(controlVolumeSliderContainer), {Start = 0, End = 1000, Increment = 1, DefaultValue = 0.5}, TweenInfo.new(0.1, Enum.EasingStyle.Quad), "X", 0)
	controlVolumeSlider:Track()

	controlVolumeSlider.Changed:Connect(function(value)
		audioLib("UpdateSound", {
			Volume = value / 100;
		})
	end)

	-- Track position
	local controlPosition = controls:Add("TextLabel", {
		Text = "   ";
		ToolTip = "Position: Control where the song is playing from.";
		BackgroundTransparency = 0;
		Size = UDim2.new(1, -135, 0, 30);
		Position = UDim2.new(0, 5, 1, -35);
		TextXAlignment = "Left";
	})

	local controlPositionSliderContainer = controlPosition:Add("Frame", {
		Image = "rbxassetid://7541896266";
		Size = UDim2.new(1, -30, 0, 2);
		Position = UDim2.new(0, 14, 0, 14);
		BackgroundColor3 = Color3.new(0.454902, 0.454902, 0.454902);
		BackgroundTransparency = 0;
	})

	local controlPositionSliderInstance = controlPositionSliderContainer:Add("ImageButton", {
		Name = "Slider";
		Size = UDim2.new(0, 10, 0, 10);
		Position = UDim2.new(0, 0, 0, -4);
		BackgroundColor3 = Color3.new(1,1,1);
		BackgroundTransparency = 0;
		TextXAlignment = "Right";
		Children = {
			UICorner = {
				CornerRadius = UDim.new(1, 0);
			}
		}
	})

	local controlPositionSlider = sliderModule.new(service.UnWrap(controlPositionSliderContainer), {Start = 0, End = 10000, Increment = 1, DefaultValue = 0.5}, TweenInfo.new(0.1, Enum.EasingStyle.Quad), "X", 0)
	controlPositionSlider:Track()

	controlPositionSlider.Changed:Connect(function(value)
		local length = audioLib("GetSound").TimeLength
		audioLib("UpdateSound", {
			TimePosition = value / 10000 * length;
		})
	end)

	-- Make the window ready before completing any code - Used to allow for delays in loading caused by MarketplaceService.

	gTable = window.gTable
	gTable:Ready()

	local function newTrackSelected(v)
		local sound = audioLib("UpdateSound", {
			SoundId = "rbxassetid://"..v.ID;
			Playing = true;
			TimePosition = 0;
		})
	end
	-- Song title and Audio Visaliser Frame.

	local heading = window:Add("TextLabel", {
		Text = "Music Player";
		Size = UDim2.new(1,0,0,20);
		BackgroundTransparency = 1;
		TextScaled = true;
		ToolTip = "Music Player";
	})

	local visualiserFrame = window:Add("Frame", {
		Size = UDim2.new(1,0,0,50);
		Position = UDim2.new(0, 0, 0, 30);
		BackgroundTransparency = 1;
		TextScaled = true;
	})

	-- Create audio vislualiser

	local visualiser = visualiserModule.new(visualiserFrame, 400)
	visualiser:LinkToSound(audioLib("GetSound"))
	if song then audioLib("UpdateSound", {
		SoundId = "rbxassetid://"..song;
		Playing = true;
		TimePosition = 0;
		})
	end

	-- Mute button

	local muteButton = window:AddTitleButton({
		Text = "";
		OnClick = function()

			if isMuted then
				audioLib("UpdateSound", {
					Volume = persistVolume;
				})
				sImg.Image = "rbxassetid://1638551696"
				isMuted = false
			else
				persistVolume = audioLib("GetSound").Volume
				audioLib("UpdateSound", {
					Volume = 0;
				})
				sImg.Image = "rbxassetid://1638584675";
				isMuted = true
			end
		end
	})

	local globalButton = nil

	if canUseGlobal then
		globalButton = window:AddTitleButton({
			Text = "";
			OnClick = function()
				audioLib("UpdateSound", {
					Playing = false;
					TimePosition = 0;
				})
				if isGlobal then
					gImg.Image = "rbxassetid://8318256297"
					isGlobal = false
					task.spawn(client.UI.Make, "Notification",{
						Title = "Global Audio";
						Icon = "rbxassetid://7541916144";
						Message = "Only you can hear your music";
						Time = 3;
					})

					audioLib = localAudioLibFunction
					audioLib("UpdateSound", {
						Playing = false;
						TimePosition = 0;
					})
					visualiser:LinkToSound(audioLib("GetSound"))
					progressupdatewait = 0.05

				else
					--updateAudio({Global = true})
					gImg.Image = "rbxassetid://8318257291";
					isGlobal = true
					task.spawn(client.UI.Make, "Notification",{
						Title = "Global Audio";
						Icon = "rbxassetid://7541916144";
						Message = "Everyone can hear your music";
						Time = 3;
					})
					audioLib = function(func, args)
						return client.Remote.Get("AudioLib", {func, args})
					end
					audioLib("UpdateSound", {
						Playing = false;
						TimePosition = 0;
					})
					visualiser:LinkToSound(audioLib("GetSound"))
					progressupdatewait = 2
				end
			end
		})
		gImg = globalButton:Add("ImageLabel", {
			Size = UDim2.new(1, 0, 1 ,0);
			Position = UDim2.new(0, 0, 0, 0);
			Image = "rbxassetid://8318256297";
			BackgroundTransparency = 1;
		})
	end

	sImg = muteButton:Add("ImageLabel", {
		Size = UDim2.new(1, 0, 1 ,0);
		Position = UDim2.new(0, 0, 0, 0);
		Image = "rbxassetid://1638551696";
		BackgroundTransparency = 1;
	})

	-- Function that makes the song list.

	local function getSongs(tab, list)
		local num = 0
		selected = nil
		if availableSongLists and availableSongLists[tab.Name] then availableSongLists[tab.Name] = nil end
		if soundInstanceEndedEvent then soundInstanceEndedEvent:Disconnect() end

		tab:ClearAllChildren();

		local frame = tab:Add("ScrollingFrame", {
			Size = UDim2.new(1, 0, 1, 1);
			Position = UDim2.new(0, 0, 0, 0);
			BackgroundColor3 = Color3.new(0.235294, 0.235294, 0.235294);
			BackgroundTransparency = 1;
		})

		local loading = frame:Add("TextLabel", {
			Text = "Loading nothing yet!";
			ToolTip = "Never gonna give you up, Never gonna let you down...";
			BackgroundTransparency = 0;
			Size = UDim2.new(1,0,1,0);
			Position = UDim2.new(0,0,0,0);
			ZIndex = 69420
			--TextXAlignment = "Left";
		})

		availableSongLists[tab.Name] = {}

		local function loop(i,v)
			if type(v) == "table" then
				loading.Text = "Loading tracks ("..i.."/"..#list..")";
				local success, product_info = pcall(function()
					return service.MarketplaceService:GetProductInfo(v.ID, Enum.InfoType.Asset)
				end)
				if product_info.AssetTypeId == 3 then
					table.insert(availableSongLists[tab.Name], v)
					frame:Add("TextButton", {
						Text = "  " .. (num + 1) .. ") " .. (success and product_info.Name or "[ERROR] "..v.Name);
						ToolTip = "Name: ".. v.Name .." | ID: "..v.ID;
						Size = UDim2.new(1, 0, 0, 25);
						Position = UDim2.new(0, 0, 0, num*25);
						BackgroundTransparency = (num%2 == 0 and 0) or 0.2;
						TextXAlignment = "Left";
						OnClicked = function(button)
							if selected and selected.Button then
								selected.Button.BackgroundTransparency = 0
							end
							button.BackgroundTransparency = 0.5

							heading.Text = success and product_info.Name or v.Name
							selected = {
								ID = v.ID,
								Name = v.Name,
								Button = button,
								Index = i
							}

							newTrackSelected(v)
						end
					})
					frame:ResizeCanvas(false, true)
				end
			end
			num = num + 1
		end

		for i,v in next,(list  or {}) do
			task.spawn(loop, i, v)
		end

		local sound = Variables.localSounds["AUDIO_PLAYER_SOUND"]

		if sound then
			soundInstanceEndedEvent = sound.Ended:Connect(function()
				if activeSongList and selected then
					if shuffle then
						local rnum
						repeat rnum = math.random(#activeSongList) until (rnum ~= selected.Index or #activeSongList <= 1)
						local toPlay = activeSongList[(rnum)]
						if toPlay then
							audioLib("UpdateSound", {
								SoundId = "rbxassetid://"..toPlay.ID;
								Playing = true;
								TimePosition = 0;
							})
							local success, product_info = pcall(function()
								return service.MarketplaceService:GetProductInfo(toPlay.ID, Enum.InfoType.Asset)
							end)
							heading.Text = success and product_info.Name or "[ERROR] "..toPlay.Name
							selected = {
								ID = toPlay.ID,
								Name = toPlay.Name,
								Button = nil,
								Index = rnum
							}
						end
					else
						local toPlay = activeSongList[(selected.Index +1)]
						if toPlay then
							audioLib("UpdateSound", {SoundId = "rbxassetid://"..toPlay.ID;
								Playing = true;
								TimePosition = 0;
							})

							local success, product_info
							local count = 0 --1

							while not success do --2
								if count >= 1 then
									wait(1) --4
								end

								success, product_info = pcall(service.MarketplaceService.GetProductInfo, service.MarketplaceService, toPlay.ID, Enum.InfoType.Asset) --5
								count = count + 1 --6
							end

							--local success, product_info = nil, nil
							--repeat pcall(function()
							--	success, product_info = service.MarketplaceService:GetProductInfo(toPlay.ID, Enum.InfoType.Asset)
							--	return success, product_info
							--end) until success == true
							heading.Text = success and product_info.Name or "[ERROR] "..toPlay.Name
							selected = {
								ID = toPlay.ID,
								Name = toPlay.Name,
								Button = nil,
								Index = selected.Index +1
							}
						end
					end
				end
			end)
		end
		loading:Destroy()
	end

	-- Tabs for different playlists

	local tabFrame = window:Add("TabFrame",{
		Size = UDim2.new(1, 0, 1, -165);
		Position = UDim2.new(0, 0, 0, 90);
	})

	local personalTab = tabFrame:NewTab("Personal",{
		Text = "Personal";
		OnFocus = function()
			activeSongList = availableSongLists["Personal"] or {}
		end;
	})
	local gameTab = tabFrame:NewTab("Game",{
		Text = "Game";
		OnFocus = function()
			activeSongList = availableSongLists["Game"] or {}
		end;
	})
	local adonisTab = tabFrame:NewTab("Adonis", {
		Text = "Adonis";
		OnFocus = function()
			activeSongList = availableSongLists["Adonis"] or {}
		end;
	})
	local customTab = tabFrame:NewTab("Custom", {
		Text = "Custom";
		OnFocus = function()
			activeSongList = availableSongLists["Custom"] or {}
		end;
	})


	--  The Custom Playlists editor window

	local binderBox; binderBox = tabFrame:Add("Frame", {
		Visible = false;
		Size = UDim2.new(1,0,1,0);
		Position = UDim2.new(0,0,0,0);
		BackgroundTransparency = 0;
		ZIndex = 10000;
		Children = {
			{
				Class = "TextLabel";
				Text = "New Custom Playlist string:";
				Position = UDim2.new(0, 5, 0, 5);
				Size = UDim2.new(1, -10, 0, 30);
				BackgroundTransparency = 0;
				ZIndex = 10001;
			};
			{
				Class = "TextButton";
				Text = "Add";
				Position = UDim2.new(0.5, 5, 1, -35);
				Size = UDim2.new(0.5, -10, 0, 30);
				BackgroundTransparency = 0;
				ZIndex = 10002;
				OnClicked = function()
				end
			};
			{
				Class = "TextButton";
				Text = "Cancel";
				Position = UDim2.new(0, 5, 1, -35);
				Size = UDim2.new(0.5, -5, 0, 30);
				BackgroundTransparency = 0;
				ZIndex = 10003;
				OnClicked = function()
					binderBox.Visible = false
				end
			};
		}
	})

	local PlaylistBox = binderBox:Add("TextBox", {
		Position = UDim2.new(0, 5, 0, 40);
		Size = UDim2.new(1, -10, 1, -80);
		TextWrapped = true;
		--TextXAlignment = "Left";
		--TextYAlignment = "Top";
		ClearTextOnFocus = false;
		PlaceholderText = "NAME:ID, SECOND:12398801, HeavyIsDead:4881542521";
		ZIndex = 10004;
		TextChanged = function(newText, enter, box)
			client.Variables.Playlist = {Playlist = {}}
			for v in pairs(client.Variables.Playlist.Playlist) do
				client.Variables.Playlist.Playlist[v] = nil
			end
			for i,v in next,(string.split(string.gsub(newText, " ", ""), ",")) do
				local split = string.split(v, ":")
				table.insert(client.Variables.Playlist.Playlist, (#client.Variables.Playlist.Playlist + 1), {
					Name = tostring(split[1]),
					ID = tonumber(split[2])
				})
			end
			binderBox.Visible = false
			getSongs(customTab, (client.Variables.Playlist.Playlist or {}))
			activeSongList = availableSongLists["Custom"] or {}
		end
	})

	PlaylistBox.BackgroundColor3 = PlaylistBox.BackgroundColor3:lerp(Color3.new(1, 1, 1), 0.1)
	binderBox.BackgroundColor3 = binderBox.BackgroundColor3:lerp(Color3.new(1, 1, 1), 0.05)

	--[[

	========================================================
	|                                                      |
	| Top control buttons (Save and load custom playlist)  |
	|                                                      |
	========================================================

	]]--

	-- Create playlist button
	local playlistLoad = controls:Add("TextButton", {
		Text = "â«";
		TextSize = 15;
		ToolTip = "Create playlist: Create a new custom playlist from a string.";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 30, 0, 30);
		Position = UDim2.new(0, 5, 0, 5);
		TextXAlignment = "Center";
		OnClicked = function()
			PlaylistBox.Text = ""
			binderBox.Visible = true
			customTab:FocusTab();
			activeSongList = availableSongLists["Custom"] or {}
		end
	})

	-- Save cutom playlist

	local playlistSave = controls:Add("TextButton", {
		Text = "â¬†ï¸";
		TextSize = 15;
		ToolTip = "Upload playlist: Saves your custom playlist to the games datastore.";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 30, 0, 30);
		Position = UDim2.new(0, 40, 0, 5);
		TextXAlignment = "Center";
		OnClicked = function()
			personalTab:FocusTab();
			local Playlist = type(client.Variables.Playlist) == "table" and client.Variables.Playlist.Playlist
			if Playlist and next(Playlist) then
				client.Functions.UpdatePlaylist(client.Variables.Playlist)
				getSongs(personalTab, ((client.Functions.Playlist()).Playlist or {}))
			else
				warn("[ERROR] Cannot update empty Playlist")
			end

			activeSongList = availableSongLists["Personal"] or {}
		end
	})

	-- Stop button
	local controlStop = controls:Add("TextButton", {
		Text = "â¹";
		TextSize = 15;
		ToolTip = "Stop: Pauses the track and sets the position to 0.";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 30, 0, 30);
		Position = UDim2.new(0, 75, 0, 5);
		TextXAlignment = "Center";
		OnClick = function()
			audioLib("UpdateSound", {
				Playing = false;
				TimePosition = 0;
			})
		end
	})

	-- Back button
	local controlBack = controls:Add("TextButton", {
		Text = "â—€ï¸";
		TextSize = 15;
		ToolTip = "Back: Go back to the last played track.";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 30, 0, 30);
		Position = UDim2.new(0, 110, 0, 5);
		TextXAlignment = "Center";
		OnClick = function()

		end
	})

	-- Pause/Play button
	local controlPausePlay = controls:Add("TextButton", {
		Text = "â¯ï¸";
		TextSize = 15;
		ToolTip = "Pause/Play: Control the tracks playing state.";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 30, 0, 30);
		Position = UDim2.new(0, 145, 0, 5);
		TextXAlignment = "Center";
		OnClick = function()
			if audioLib("GetSound") then
				audioLib("UpdateSound", {
					Playing = not audioLib("GetSound").Playing
				})
			end
		end
	})

	-- Forward button
	local controlForward = controls:Add("TextButton", {
		Text = "â–¶ï¸";
		TextSize = 15;
		ToolTip = "Forward: Skip to the next track.";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 30, 0, 30);
		Position = UDim2.new(0, 180, 0, 5);
		TextXAlignment = "Center";
		OnClick = function()

		end
	})

	-- Forward button

	local controlShuffle = nil
	local controlShuffleBackgroundColor3 = nil
	local function changeShuffleColor()
		if shuffle then
			controlShuffle.BackgroundColor3 = Color3.new(0, 1, 0.6)
		else
			controlShuffle.BackgroundColor3 = controlShuffleBackgroundColor3
		end
	end
	controlShuffle = controls:Add("TextButton", {
		Text = "ðŸ”€";
		TextSize = 15;
		ToolTip = "Shuffle: Randomly pick between.";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 30, 0, 30);
		Position = UDim2.new(0, 215, 0, 5);
		TextXAlignment = "Center";
		OnClick = function()
			shuffle = not shuffle
			changeShuffleColor()
		end
	})

	controlShuffleBackgroundColor3 = controlShuffle.BackgroundColor3

	-- Loop button

	local controlLoop = nil
	local controlLoopBackgroundColor3 = nil
	local function changeLoopColor()
		if loop then
			controlLoop.BackgroundColor3 = Color3.new(0, 1, 0.6)
		else
			controlLoop.BackgroundColor3 = controlLoopBackgroundColor3
		end
	end
	controlLoop = controls:Add("TextButton", {
		Text = "ðŸ”";
		TextSize = 15;
		ToolTip = "Loop: Loops the song continuously.";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 30, 0, 30);
		Position = UDim2.new(0, 250, 0, 5);
		TextXAlignment = "Center";
		OnClick = function()
			loop = not loop
			changeLoopColor()
			audioLib("UpdateSound", {
				Looped = loop;
			})
		end
	})
	controlLoopBackgroundColor3 = controlLoop.BackgroundColor3

	-- Bottom control buttons

	-- Custom Sound ID

	local controlID = controls:Add("TextLabel", {
		Text = "  ID: ";
		ToolTip = "ID: The Sound ID from the roblox catalogue.";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 120, 0, 30);
		Position = UDim2.new(1, -125, 0, 5);
		TextXAlignment = "Left";
		Children = {
			TextBox = {
				Text = "";
				PlaceholderText = "4881542521";
				Size = UDim2.new(0, 80, 1, 0);
				Position = UDim2.new(1, -90, 0, 0);
				BackgroundTransparency = 1;
				TextXAlignment = "Right";
				TextChanged = function(text, enter, new)
					if enter then
						audioLib("UpdateSound", {
							SoundId = "rbxassetid://"..text;
							Playing = true;
							TimePosition = 0;
						})
					end
				end
			}
		}
	})

	-- Position
	--local controlPosition = controls:Add("TextLabel", {
	--	Text = "  Pos: ";
	--	ToolTip = "Position: Set the audio's position (In seconds).";
	--	BackgroundTransparency = 0;
	--	Size = UDim2.new(0, 60, 0, 30);
	--	Position = UDim2.new(1, -205, 1, -35);
	--	TextXAlignment = "Left";
	--	Children = {
	--		TextBox = {
	--			Text = "";
	--			PlaceholderText = "0";
	--			Size = UDim2.new(0, 40, 1, 0);
	--			Position = UDim2.new(1, -50, 0, 0);
	--			BackgroundTransparency = 1;
	--			TextXAlignment = "Right";
	--			TextChanged = function(text, enter, new)
	--				if enter then
	--					audioLib("UpdateSound", {
	--						TimePosition = text
	--					})
	--				end
	--			end
	--		}
	--	}
	--})

	--[[

	========================================================
	|                                                      |
	| Bottom control buttons (Position and volume slider)  |
	|                                                      |
	========================================================

	]]--

	-- Volume
	local controlVolume = controls:Add("TextLabel", {
		Text = "   ";
		ToolTip = "Volume: How loud the audio will play (0 to 10).";
		BackgroundTransparency = 0;
		Size = UDim2.new(0, 120, 0, 30);
		Position = UDim2.new(1, -125, 1, -35);
		TextXAlignment = "Left";
	})

	controlVolume:Add("ImageLabel", {
		Image = "rbxassetid://7541896266";
		Size = UDim2.new(0, 20, 0, 20);
		Position = UDim2.new(0, 5, 0, 5);
		BackgroundTransparency = 1;
	})

	local controlVolumeSliderContainer = controlVolume:Add("Frame", {
		Image = "rbxassetid://7541896266";
		Size = UDim2.new(1, -45, 0, 2);
		Position = UDim2.new(0, 30, 0, 14);
		BackgroundColor3 = Color3.new(0.454902, 0.454902, 0.454902);
		BackgroundTransparency = 0;
	})

	local controlVolumeSliderInstance = controlVolumeSliderContainer:Add("ImageButton", {
		Name = "Slider";
		--Text = "";
		Size = UDim2.new(0, 10, 0, 10);
		Position = UDim2.new(0, 0, 0, -4);
		BackgroundColor3 = Color3.new(1,1,1);
		BackgroundTransparency = 0;
		TextXAlignment = "Right";
		Children = {
			UICorner = {
				CornerRadius = UDim.new(1, 0);
			}
		}
	})

	local controlVolumeSlider = sliderModule.new(service.UnWrap(controlVolumeSliderContainer), {Start = 0, End = 1000, Increment = 1, DefaultValue = 0.5}, TweenInfo.new(0.1, Enum.EasingStyle.Quad), "X", 0)
	controlVolumeSlider:Track()

	controlVolumeSlider.Changed:Connect(function(value)
		audioLib("UpdateSound", {
			Volume = value / 100;
		})
	end)

	-- Track position
	local controlPosition = controls:Add("TextLabel", {
		Text = "   ";
		ToolTip = "Position: Control where the song is playing from.";
		BackgroundTransparency = 0;
		Size = UDim2.new(1, -135, 0, 30);
		Position = UDim2.new(0, 5, 1, -35);
		TextXAlignment = "Left";
	})

	local controlPositionSliderContainer = controlPosition:Add("Frame", {
		Image = "rbxassetid://7541896266";
		Size = UDim2.new(1, -30, 0, 2);
		Position = UDim2.new(0, 14, 0, 14);
		BackgroundColor3 = Color3.new(0.454902, 0.454902, 0.454902);
		BackgroundTransparency = 0;
	})

	local controlPositionSliderInstance = controlPositionSliderContainer:Add("ImageButton", {
		Name = "Slider";
		Size = UDim2.new(0, 10, 0, 10);
		Position = UDim2.new(0, 0, 0, -4);
		BackgroundColor3 = Color3.new(1,1,1);
		BackgroundTransparency = 0;
		TextXAlignment = "Right";
		Children = {
			UICorner = {
				CornerRadius = UDim.new(1, 0);
			}
		}
	})

	local controlPositionSlider = sliderModule.new(service.UnWrap(controlPositionSliderContainer), {Start = 0, End = 10000, Increment = 1, DefaultValue = 0.5}, TweenInfo.new(0.1, Enum.EasingStyle.Quad), "X", 0)
	controlPositionSlider:Track()

	controlPositionSlider.Changed:Connect(function(value)
		local length = audioLib("GetSound").TimeLength
		audioLib("UpdateSound", {
			TimePosition = value / 10000 * length;
		})
	end)

	-- Used to play a sound on window open. 4881542521.

	-- Create OnClose event after everything has been initialised

	-- Load in track lists

	local loadingMessage = function(tab)
		tab:Add("TextLabel", {
			Text = "Waiting in queue to load tracks...";
			ToolTip = "Never gonna give you up, Never gonna let you down...";
			BackgroundTransparency = 0;
			Size = UDim2.new(1,0,1,0);
			Position = UDim2.new(0,0,0,0);
			ZIndex = 69420
			--TextXAlignment = "Left";
		})
	end

	loadingMessage(personalTab)
	loadingMessage(gameTab)
	loadingMessage(adonisTab)
	getSongs(personalTab, ((client.Functions.Playlist()).Playlist or {}))
	getSongs(gameTab, (client.Remote.Get("Variable", "MusicList") or {}))
	getSongs(adonisTab, (client.Remote.Get("Variable", "MusicList") or {}))
	activeSongList = availableSongLists["Personal"] or {}

	task.spawn(function()
		local tempsound = audioLib("GetSound")
		while task.wait(progressupdatewait) do
			tempsound = audioLib("GetSound")
			if tempsound and tempsound.TimeLength ~= 0 then
				controlPositionSlider:OverrideVisualValue(tempsound.TimePosition / tempsound.TimeLength * 10000)
			end
		end
	end)
end]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBX55DC8D6E05C04085B2FE7A16B8B4D3A9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Visualizer</string>
				<string name="ScriptGuid">{0087460F-28F3-4168-B330-7401BCFC92E4}</string>
				<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local module = {}

local function AlphaColorSequence(Sequence, Alpha)
	local Keypoints = Sequence.Keypoints
	local StartKeypoint, EndKeypoint = 1, #Keypoints

	for i, Keypoint in ipairs(Keypoints) do
		if Keypoint.Time >= Alpha then
			EndKeypoint = Keypoint
			StartKeypoint = Keypoints[math.max(1, i-1)]
			break
		end
	end

	local StartTime, EndTime = StartKeypoint.Time, EndKeypoint.Time
	local StartValue, EndValue = StartKeypoint.Value, EndKeypoint.Value

	local KeyframeAlpha = (Alpha - StartTime) / (EndTime - StartTime)

	return StartValue:Lerp(EndValue, KeyframeAlpha)
end

function module.new(Frame, BarCount)

	-- Determine settings
	local BAR_COUNT = math.clamp(type(BarCount) == "number" and BarCount or 41, 11,601)
	local SAMPLE_HZ = math.clamp(BAR_COUNT/2,10,500)

	if BAR_COUNT%2==0 then
		BAR_COUNT += 1
	end

	local BAR_SIZE = 1/BAR_COUNT
	local BUFFER_COUNT = math.ceil(BAR_COUNT/2)
	local BAR_TO_BUFFER = table.create(BAR_COUNT)
	local BAR_TO_MULTIPLIER = table.create(BAR_COUNT)

	for i=1, BAR_COUNT do
		BAR_TO_BUFFER[i] = math.abs(BUFFER_COUNT- (i+ (i<=BUFFER_COUNT and -1 or 1) ))
		BAR_TO_MULTIPLIER[i] = 1-(math.clamp(math.abs(BUFFER_COUNT- (i+ (i<=BUFFER_COUNT and -1 or 1) ))/BUFFER_COUNT, 0.01,1)^2)
	end

	local UPDATE_WAIT = 1/SAMPLE_HZ

	-- Setup visualizer

	local Visualizer = {
		Frame = Frame;
		VolumeBuffer = table.create(BUFFER_COUNT+1);
		Bars = {};
		BufferConnection = nil;
		PlayingConnection = nil;
		Sound = nil;
	}

	-- Create the bar guis
	for i=1, BAR_COUNT do

		local Bar = Frame:Add("Frame", {
			BorderSizePixel = 0;
			BackgroundColor3 = Color3.new(0.98,0.98,0.99);
			AnchorPoint = Vector2.new(0,0.5);
			Size = UDim2.new(BAR_SIZE,0,0.02,0);
			Position = UDim2.new(BAR_SIZE* (i-1), 0,0.5,0);
		})

		Visualizer.Bars[i] = Bar
	end

	local function HandlePlaying()
		if Visualizer.BufferConnection then
			Visualizer.BufferConnection:Disconnect()
			Visualizer.BufferConnection = nil
		end

		local Sound = Visualizer.Sound
		if not Sound then return end

		if Sound.Playing then
			local LastStored = os.clock()
			Visualizer.BufferConnection = RunService.Heartbeat:Connect(function()
				local success, void = pcall(function()
					Visualizer.VolumeBuffer[1] = Sound.PlaybackLoudness
					Visualizer.Bars[BUFFER_COUNT]:TweenSize(
						UDim2.new(
							BAR_SIZE,0,
							math.clamp((Sound.PlaybackLoudness/400), 0.02,1),0
						),
						Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.014, true
					)

					if os.clock()-LastStored > UPDATE_WAIT then
						LastStored = os.clock()

						table.insert(Visualizer.VolumeBuffer,1,Sound.PlaybackLoudness)
						local Length = #Visualizer.VolumeBuffer
						if Length > BUFFER_COUNT then
							Visualizer.VolumeBuffer[#Visualizer.VolumeBuffer] = nil
						end

						local Color = Visualizer.Color
						local ColorType = typeof(Color)

						for i,Bar in ipairs(Visualizer.Bars) do

							local Alpha = math.clamp(
								((Visualizer.VolumeBuffer[BAR_TO_BUFFER[i]] or 0)/400),
								0.02, 1
							)

							Bar:TweenSize(
								UDim2.new(
									BAR_SIZE,0,
									Alpha,0
								),
								Enum.EasingDirection.Out, Enum.EasingStyle.Linear, UPDATE_WAIT, true
							)

							if Color then
								if ColorType == "Color3" then
									Bar.BackgroundColor3 = Color
								elseif ColorType == "ColorSequence" then
									Bar.BackgroundColor3 = AlphaColorSequence(Color, Alpha)
								end
							end

						end
					end
				end)
				if not success then Visualizer:UnlinkFromSound() end
			end)
		else
			table.clear(Visualizer.VolumeBuffer)
			for i,Bar in ipairs(Visualizer.Bars) do
				Bar:TweenSize(
					UDim2.new(BAR_SIZE,0,0.02,0),
					Enum.EasingDirection.Out, Enum.EasingStyle.Linear, UPDATE_WAIT, true
				)
			end
		end
	end

	function Visualizer:LinkToSound(Sound)

		Visualizer:UnlinkFromSound()

		table.clear(Visualizer.VolumeBuffer)

		Visualizer.Sound = Sound

		HandlePlaying()
		Visualizer.PlayingConnection = Sound:GetPropertyChangedSignal("Playing"):Connect(HandlePlaying)
	end

	function Visualizer:UnlinkFromSound()

		if Visualizer.PlayingConnection then
			Visualizer.PlayingConnection:Disconnect()
			Visualizer.PlayingConnection = nil
		end
		if Visualizer.BufferConnection then
			Visualizer.BufferConnection:Disconnect()
			Visualizer.BufferConnection = nil
		end

		Visualizer.Sound = nil

		for i,Bar in ipairs(Visualizer.Bars) do
			Bar:TweenSize(
				UDim2.new(BAR_SIZE,0,0.02,0),
				Enum.EasingDirection.Out, Enum.EasingStyle.Linear, UPDATE_WAIT, true
			)
		end

	end

	function Visualizer:Destroy()
		if Visualizer.PlayingConnection then
			Visualizer.PlayingConnection:Disconnect()
			Visualizer.PlayingConnection = nil
		end
		if Visualizer.BufferConnection then
			Visualizer.BufferConnection:Disconnect()
			Visualizer.BufferConnection = nil
		end
		for i,Bar in ipairs(Visualizer.Bars) do
			Bar:Destroy()
		end
		table.clear(Visualizer.VolumeBuffer)
	end


	return Visualizer
end

return module
]]></ProtectedString>
				<int64 name="SourceAssetId">6360148029</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXE1ED3420B5C642718907349EE161AD87">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Slider</string>
				<string name="ScriptGuid">{8AD85B7A-B61C-4D68-9106-50EA59AAF9B7}</string>
				<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------------------
-------------------------------------- Slider Module ---------------------------------------
-- [Adonis Maintainer]: P3tray
-- [Author]: Krypt
-- [Description]: Creates a slider based on a start, end and incremental value. Allows ...
-- ... sliders to be moved, tracked/untracked, reset, and have specific properties such ...
-- ... as their current value and increment to be overriden.

-- [Created]: 22/12/2021
-- [Edited]: 18/01/2022
-- [Dev Forum Link]: https://devforum.roblox.com/t/1597785/
--------------------------------------------------------------------------------------------

--!nonstrict
local Slider = {
	Sliders = {}
}

local RunService = game:GetService("RunService")

if not RunService:IsClient() then
	error("Slider module can only be used on the Client!", 2)
	return nil
end

local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local Clamp = math.clamp
local Floor = math.floor
local Min = math.min
local Max = math.max
local Round = math.round

local Lower = string.lower
local Upper = string.upper
local Sub = string.sub
local Format = string.format

local Signal = require(script.Parent.Signal)

Slider.__index = function(object, indexed)
	local deprecated = {
		{".OnChange", ".Changed", object.Changed}
	}

	for _, tbl in ipairs(deprecated) do
		local deprecatedStr = Sub(tbl[1], 2)

		if deprecatedStr == indexed then
			warn(Format("%s is deprecated, please use %s instead", tbl[1], tbl[2]))
			return tbl[3]
		end
	end

	return Slider[indexed]
end

export type sliderConfigDictionary = {[string]: number}

function snapToScale(val, step)
	return Clamp(Floor(val / step) * step, 0, 1)
end

function lerp(start, finish, percent)
	return (1 - percent) * start + percent * finish
end

function map(value, start, stop, newStart, newEnd, constrain)
	local newVal = lerp(newStart, newEnd, getAlphaBetween(start, stop, value))
	if not constrain then
		return newVal
	end

	if newStart < newEnd then
		newStart, newEnd = newEnd, newStart
	end

	return Max(Min(newVal, newStart), newEnd)
end

function getNewPosition(self, percent)
	local absoluteSize = self._button.AbsoluteSize[self._axis]
	local holderSize = self._holder.AbsoluteSize[self._axis]

	local anchorPoint = self._button.AnchorPoint[self._axis]

	local paddingScale = (self._padding / holderSize)

	local minScale = (
		(anchorPoint * absoluteSize) / holderSize +
		paddingScale
	)

	local decrement = ((2 * absoluteSize) * anchorPoint) - absoluteSize
	local maxScale = (1 - minScale) + (decrement / holderSize)

	local newPercent = map(percent or self._percent, 0, 1, minScale, maxScale, true)

	if self._axis == "X" then
		return UDim2.new(newPercent, self._button.Position.X.Offset, self._button.Position.Y.Scale, self._button.Position.Y.Offset)
	elseif self._axis == "Y" then
		return UDim2.fromScale(self._button.Position.X.Scale, newPercent)
	end
end

function getScaleIncrement(self)
	return 1 / ((self._config.End - self._config.Start) / self._config.Increment)
end

function getAlphaBetween(a, b, c)
	return (c - a) / (b - a)
end

function getNewValue(self)
	local newValue = lerp(self._config.Start, self._config.End, self._percent)
	local incrementScale = (1 / self._config.Increment)

	newValue = Floor(newValue * incrementScale) / incrementScale
	return newValue
end

function Slider.new(holder: any, configuration: sliderConfigDictionary, moveTweenInfo: TweenInfo, axis: string, padding: number)
	assert(pcall(function()
		return holder.AbsoluteSize, holder.AbsolutePosition
	end), "Holder argument does not have an AbsoluteSize/AbsolutePosition")

	local sliderBtn = holder:FindFirstChild("Slider")
	assert(sliderBtn ~= nil, "Failed to find slider button.")
	assert(sliderBtn:IsA("GuiButton"), "Slider is not a GuiButton")

	local duplicate = false
	for _, slider in ipairs(Slider.Sliders) do
		if slider._holder == holder then
			duplicate = true
			break
		end
	end

	assert(not duplicate, "Cannot set two sliders with same frame!")
	assert(configuration.Increment ~= nil, "Failed to find Increment in configuration table")
	assert(configuration.Start ~= nil, "Failed to find Start in configuration table")
	assert(configuration.End ~= nil, "Failed to find End in configuration table")
	assert(configuration.Increment > 0, "Increment must be greater than 0")
	assert(configuration.End > configuration.Start, "Config.End must be greater than Config.Start (" .. configuration.End .. " <= " .. configuration.Start .. ")")

	axis = axis or "x"
	axis = Lower(axis)
	assert(axis == "x" or axis == "y", "Axis must be X or Y!")

	assert(typeof(moveTweenInfo) == "TweenInfo", "MoveTweenInfo must be a TweenInfo object!")

	padding = padding or 5
	assert(type(padding) == "number", "Padding variable must be a number!")

	local self = setmetatable({}, Slider)

	self._holder = holder
	self._button = sliderBtn
	self._config = configuration
	self._axis = Upper(axis)
	self._padding = padding

	self.IsHeld = false
	self._mainConnection = nil
	self._buttonConnections = {}
	self._inputPos = nil

	self._percent = 0
	if configuration.DefaultValue then
		configuration.DefaultValue = Clamp(configuration.DefaultValue, configuration.Start, configuration.End)
		self._percent = getAlphaBetween(configuration.Start, configuration.End, configuration.DefaultValue)
	end
	self._percent = Clamp(self._percent, 0, 1)

	self._value = getNewValue(self)
	self._scaleIncrement = getScaleIncrement(self)

	self._currentTween = nil
	self._tweenInfo = moveTweenInfo or TweenInfo.new(1)

	self.Changed = Signal.new()
	self.Dragged = Signal.new()
	self.Released = Signal.new()

	self:Move()
	table.insert(Slider.Sliders, self)

	return self
end

function Slider:Track()
	for _, connection in ipairs(self._buttonConnections) do
		connection:Disconnect()
	end

	table.insert(self._buttonConnections, self._button.MouseButton1Down:Connect(function()
		self.IsHeld = true
	end))

	table.insert(self._buttonConnections, self._button.MouseButton1Up:Connect(function()
		if self.IsHeld then
			self.Released:Fire(self._value)
		end
		self.IsHeld = false
	end))

	if self.Changed then
		self.Changed:Fire(self._value)
	end

	if self._mainConnection then
		self._mainConnection:Disconnect()
	end

	self._mainConnection = UserInputService.InputChanged:Connect(function(inputObject, gameProcessed)
		if inputObject.UserInputType == Enum.UserInputType.MouseMovement or inputObject.UserInputType == Enum.UserInputType.Touch then
			self._inputPos = inputObject.Position
			self:Update()
		end
	end)
end

function Slider:Update()
	if self.IsHeld and self._inputPos then
		local mousePos = self._inputPos[self._axis]

		local sliderSize = self._holder.AbsoluteSize[self._axis]
		local sliderPos = self._holder.AbsolutePosition[self._axis]
		local newPos = snapToScale((mousePos - sliderPos) / sliderSize, self._scaleIncrement)

		local percent = Clamp(newPos, 0, 1)
		self._percent = percent
		self:Move()
		self.Dragged:Fire(self._value)
	end
end

function Slider:Untrack()
	for _, connection in ipairs(self._buttonConnections) do
		connection:Disconnect()
	end
	if self._mainConnection then
		self._mainConnection:Disconnect()
	end
	self.IsHeld = false
end

function Slider:Reset()
	for _, connection in ipairs(self._buttonConnections) do
		connection:Disconnect()
	end
	if self._mainConnection then
		self._mainConnection:Disconnect()
	end

	self.IsHeld = false

	self._percent = 0
	if self._config.DefaultValue then
		self._percent = getAlphaBetween(self._config.Start, self._config.End, self._config.DefaultValue)
	end
	self._percent = Clamp(self._percent, 0, 1)
	self:Move()
end

function Slider:OverrideValue(newValue: number)
	self.IsHeld = false
	self._percent = getAlphaBetween(self._config.Start, self._config.End, newValue)
	self._percent = Clamp(self._percent, 0, 1)
	self._percent = snapToScale(self._percent, self._scaleIncrement)
	self:Move()
end

function Slider:Move()
	self._value = getNewValue(self)

	if self._currentTween then
		self._currentTween:Cancel()
	end
	self._currentTween = TweenService:Create(self._button, self._tweenInfo, {
		Position = getNewPosition(self)
	})

	self._currentTween:Play()
	self.Changed:Fire(self._value)
end

function Slider:OverrideVisualValue(newValue: number)
	if self.IsHeld then
		return false
	end

	local percent = getAlphaBetween(self._config.Start, self._config.End, newValue)
	percent = Clamp(percent, 0, 1)
	percent = snapToScale(percent, self._scaleIncrement)

	if self._currentTween then
		self._currentTween:Cancel()
	end
	self._currentTween = TweenService:Create(self._button, self._tweenInfo, {
		Position = getNewPosition(self, percent)
	})

	self._currentTween:Play()
end

function Slider:OverrideIncrement(newIncrement: number)
	self._config.Increment = newIncrement
	self._scaleIncrement = getScaleIncrement(self)
	self._percent = Clamp(self._percent, 0, 1)
	self._percent = snapToScale(self._percent, self._scaleIncrement)
	self:Move()
end

function Slider:GetValue()
	return self._value
end

function Slider:GetIncrement()
	return self._increment
end

function Slider:Destroy()
	for _, connection in ipairs(self._buttonConnections) do
		connection:Disconnect()
	end
	if self._mainConnection then
		self._mainConnection:Disconnect()
	end
	self.Changed:Destroy()
	self.Dragged:Destroy()
	self.Released:Destroy()

	for index = 1, #Slider.Sliders do
		if Slider.Sliders[index] == self then
			table.remove(Slider.Sliders, index)
		end
	end

	setmetatable(self, nil)
	self = nil
end

UserInputService.InputEnded:Connect(function(inputObject, internallyProcessed)
	if inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch then
		for _, slider in ipairs(Slider.Sliders) do
			if slider.IsHeld then
				slider.Released:Fire(slider._value)
			end
			slider.IsHeld = false
		end
	end
end)

return Slider

-----------------------------------------------------------------------------------------]]></ProtectedString>
				<int64 name="SourceAssetId">8314798830</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXA897A4EADC994B4E922A595FEE341EC2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Signal</string>
				<string name="ScriptGuid">{9ACE78A1-7123-447F-B11E-921DE1E2E90F}</string>
				<ProtectedString name="Source"><![CDATA[----------------------------- Signal Module -----------------------------
-- > Used to create, connect, wait and destroy signals.
-- > Created by Quenty
-----------------------------------------------------------------------------------------

--- Lua-side duplication of the API of events on Roblox objects.
-- Signals are needed for to ensure that for local events objects are passed by
-- reference rather than by value where possible, as the BindableEvent objects
-- always pass signal arguments by value, meaning tables will be deep copied.
-- Roblox's deep copy method parses to a non-lua table compatable format.
-- @classmod Signal

local Signal = {}
Signal.__index = Signal
Signal.ClassName = "Signal"

--- Constructs a new signal.
-- @constructor Signal.new()
-- @treturn Signal
function Signal.new()
	local self = setmetatable({}, Signal)

	self._bindableEvent = Instance.new("BindableEvent")
	self._argData = nil
	self._argCount = nil -- Prevent edge case of :Fire("A", nil) --> "A" instead of "A", nil

	return self
end

--- Fire the event with the given arguments. All handlers will be invoked. Handlers follow
-- Roblox signal conventions.
-- @param ... Variable arguments to pass to handler
-- @treturn nil
function Signal:Fire(...)
	self._argData = {...}
	self._argCount = select("#", ...)
	self._bindableEvent:Fire()
	self._argData = nil
	self._argCount = nil
end

--- Connect a new handler to the event. Returns a connection object that can be disconnected.
-- @tparam function handler Function handler called with arguments passed when `:Fire(...)` is called
-- @treturn Connection Connection object that can be disconnected
function Signal:Connect(handler)
	if not (type(handler) == "function") then
		error(("connect(%s)"):format(typeof(handler)), 2)
	end

	return self._bindableEvent.Event:Connect(function()
		handler(unpack(self._argData, 1, self._argCount))
	end)
end

--- Wait for fire to be called, and return the arguments it was given.
-- @treturn ... Variable arguments from connection
function Signal:Wait()
	self._bindableEvent.Event:Wait()
	assert(self._argData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
	return unpack(self._argData, 1, self._argCount)
end

--- Disconnects all connected events to the signal. Voids the signal as unusable.
-- @treturn nil
function Signal:Destroy()
	if self._bindableEvent then
		self._bindableEvent:Destroy()
		self._bindableEvent = nil
	end

	self._argData = nil
	self._argCount = nil
end

return Signal]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ImageLabel" referent="RBX3140CF2107434B799D865A8D91582A46">
			<Properties>
				<bool name="Active">false</bool>
				<Vector2 name="AnchorPoint">
					<X>0</X>
					<Y>0</Y>
				</Vector2>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<token name="AutomaticSize">0</token>
				<Color3 name="BackgroundColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<float name="BackgroundTransparency">0</float>
				<Color3 name="BorderColor3">
					<R>0.105882362</R>
					<G>0.164705887</G>
					<B>0.207843155</B>
				</Color3>
				<token name="BorderMode">0</token>
				<int name="BorderSizePixel">1</int>
				<bool name="ClipsDescendants">false</bool>
				<bool name="Draggable">false</bool>
				<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
				<Color3 name="ImageColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<Vector2 name="ImageRectOffset">
					<X>0</X>
					<Y>0</Y>
				</Vector2>
				<Vector2 name="ImageRectSize">
					<X>0</X>
					<Y>0</Y>
				</Vector2>
				<float name="ImageTransparency">0</float>
				<int name="LayoutOrder">0</int>
				<string name="Name">ImageLabel</string>
				<Ref name="NextSelectionDown">null</Ref>
				<Ref name="NextSelectionLeft">null</Ref>
				<Ref name="NextSelectionRight">null</Ref>
				<Ref name="NextSelectionUp">null</Ref>
				<UDim2 name="Position">
					<XS>0</XS>
					<XO>0</XO>
					<YS>0</YS>
					<YO>0</YO>
				</UDim2>
				<token name="ResampleMode">0</token>
				<Ref name="RootLocalizationTable">null</Ref>
				<float name="Rotation">0</float>
				<token name="ScaleType">0</token>
				<bool name="Selectable">false</bool>
				<token name="SelectionBehaviorDown">0</token>
				<token name="SelectionBehaviorLeft">0</token>
				<token name="SelectionBehaviorRight">0</token>
				<token name="SelectionBehaviorUp">0</token>
				<bool name="SelectionGroup">false</bool>
				<Ref name="SelectionImageObject">null</Ref>
				<int name="SelectionOrder">0</int>
				<UDim2 name="Size">
					<XS>0</XS>
					<XO>100</XO>
					<YS>0</YS>
					<YO>100</YO>
				</UDim2>
				<token name="SizeConstraint">0</token>
				<Rect2D name="SliceCenter">
					<min>
						<X>0</X>
						<Y>0</Y>
					</min>
					<max>
						<X>0</X>
						<Y>0</Y>
					</max>
				</Rect2D>
				<float name="SliceScale">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UDim2 name="TileSize">
					<XS>1</XS>
					<XO>0</XO>
					<YS>1</YS>
					<YO>0</YO>
				</UDim2>
				<bool name="Visible">true</bool>
				<int name="ZIndex">1</int>
			</Properties>
		</Item>
	</Item>
</roblox>
