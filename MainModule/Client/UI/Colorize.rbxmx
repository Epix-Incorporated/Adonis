<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBXD71C70FBDF4B49F086AAF6446BE520D8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">Colorize</string>
			<string name="ScriptGuid">{DEDB902C-524D-428E-960D-26616B5E97ED}</string>
			<ProtectedString name="Source"><![CDATA[--// You can use modules like this to alter guis without making a new theme
--// This makes it so you don't need to make an entire gui folder n all that
--// If the theme is set to this module, it will use the default guis
--// The default requested gui will be passed to and modified by this module
--// before it runs. This lets you change things in anyway you want without
--// needing to change the guis by hand or their code.
--// This is also generally safer and update proof.
--// Alternatively if this returns anything, it will be assumed
--// that this module created and registered it's own screenguis
--// It will assume that any return is from those guis
--// For instance the YesNoPrompt returns Yes or No depending on
--// what button the player presses.
--// Any non-nil return will be returned by the script
--// IF YOU MAKE YOUR OWN SCREENGUIS IT IS UP TO YOU TO REGISTER THEM!
--// If you plan to make your own guis you must return something from this module
--// and you must register them using client.UI.Register(ScreenGuiObjectHere)
--// Register will return gTable and gIndex, when destroying your gui
--// use gTable:Destroy(); If your gui needs to be removed in a special way
--// you can define a custom destroy function by doing
--// gTable.CustomDestroy = function() doStuffHere end

--// If this module returns a ScreenGui object, the script will use that as the gui and 
--// take care of registering and running the code module n all that.
--// RETURNED SCREENGUI MUST CONTAIN A "Config" FOLDER; 
--// If no Code module is given the default code module will be used.

--[[
	~= EXAMPLE CODE =~
	return function(gui,gTable,guiData)
		local name = gTable.Name
		if name == "YesNoPrompt" then
			local new = Instance.new("ScreenGui")
			local frame = Instance.new("Frame",new)
			frame.Size = UDim2.new(0,400,0,400)
			local yes = Instance.new("TextButton",frame)
			yes.Size = UDim2.new(0.5,0,1,0)
			yes.Text = "Yes"
			local no = yes:Clone()
			no.Text = "No"
			no.Position = UDim2.new(0.5,0,0,0)
			
			local gTable,gIndex = client.UI.Register(new)
			
			local ans
			local waiting = true
			
			gTable.CustomDestroy = function()
				waiting = false
			end
			
			yes.MouseButton1Click:connect(function()
				ans = "Yes"
				gTable:Destroy()
			end)
			
			no.MouseButton1Click:connect(function()
				ans = "No"
				gTable:Destroy()
			end)
			
			repeat wait() until ans or not waiting  --// Wait until answer
			return ans or false
		end
	end
	
--]]

service = nil
Routine = nil
client = nil

return function(gui, guiData, gTable)
	local contents = {}
	local OrgColors = {}
	local classes = {
		Frame = true;
		TextBox = true;
		TextLabel = true;
		TextButton = true;
		ImageLabel = true;
		ImageButton = true; 
		ScrollingFrame = true;
	}
	
	local function getCont(obj)
		for i,v in ipairs(obj:GetChildren()) do 
			if classes[v.ClassName] then
				table.insert(contents,v)
				local OrgColor = {}
				OrgColor.Background = v.BackgroundColor3
				if v:IsA("ImageLabel") or v:IsA("ImageButton") then 
					OrgColor.Image = v.ImageColor3 
				end
				OrgColors[v] = OrgColor
				getCont(v)
			end
		end
	end
	
	if classes[gui.ClassName] then
		table.insert(contents,gui)
		local OrgColor = {}
		OrgColor.Background = gui.BackgroundColor3
		if gui:IsA("ImageLabel") or gui:IsA("ImageButton") then 
			OrgColor.Image = gui.ImageColor3 
		end
		OrgColors[gui] = OrgColor
	end
	
	getCont(gui)
	
	if gTable.Name == "List" then
		gui.Drag.Main.BackgroundTransparency = 0
	end
	
	local tweenTime = 2
	local sequence = {
		Color3.fromRGB(255, 85, 88), 
		Color3.fromRGB(78, 140, 255), 
		Color3.fromRGB(78, 255, 149)
	}
	
	local function tweenToColor(color1, color2, time)
		local Info = TweenInfo.new(time)
		for i2,v in ipairs(contents) do
			local orgcolor = OrgColors[v]
			if v.Name ~= "CapeColor" and v.Name ~= "Color" then
				if v:IsA("ImageLabel") or v:IsA("ImageButton") then
					service.TweenService:Create(v, Info, {
						BackgroundColor3 = color2:lerp(orgcolor.BackgroundColor3, 0.75),
						ImageColor3 = color2:lerp(orgcolor.Image, 0.75)
					}):Play()
				else
					service.TweenService:Create(v, Info, {
						BackgroundColor3 = color2:lerp(orgcolor.BackgroundColor3, 0.75)
					}):Play()
				end
			end
		end
		task.wait(time)
	end
	
	service.TrackTask("Thread: Colorize_"..tostring(gTable.Name),function()
		while ((gTable.Active and task.wait()) or task.wait(1)) and not gTable.Destroyed do
			for i,v in ipairs(sequence) do
				local one, two = sequence[i], sequence[i+1] or sequence[1]
				
				tweenToColor(one, two, tweenTime)
			end
		end
	end)
end]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="StringValue" referent="RBX37E05A28E4254A29A2D1C2A3769B245B">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Base_Theme</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<string name="Value">Default</string>
			</Properties>
		</Item>
	</Item>
</roblox>